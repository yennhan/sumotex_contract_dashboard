{
    "lang":"rust",
    "value":"use std::collections::HashMap;\nuse bincode::{serialize_into, deserialize_from};\nuse serde::{Serialize, Deserialize};\nuse std::io::Cursor;\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\nuse bincode::{serialize};\nuse erc20_macro::generate_abi;\nuse std::ffi::{CString, CStr};\n\n#[derive(Serialize, Deserialize,Clone)]\npub struct ERC721Token {\n    pub name: String,\n    pub symbol: String,\n    pub owner_of: Vec<String>,        // Vector to store owner addresses\n    pub token_to_ipfs: Vec<String>,    // Vector to store IPFS hashes\n    //pub owner_of: HashMap<u64, String>,  // tokenId -> owner address\n    //pub token_to_ipfs: HashMap<u64, String>,  // tokenId -> IPFS hash\n    pub token_id: u64,\n}\n\n#[derive(Serialize, Deserialize, Clone)]\npub struct TokenDetails {\n    pub owner: String,\n    pub ipfs_link: String,\n}\n\nfn extract_string_from_wasm_memory(ptr: *mut u8, len: usize) -> String {\n    let slice = unsafe { std::slice::from_raw_parts(ptr, len) };\n    String::from_utf8_lossy(slice).to_string()\n}\n\npub struct GlobalState {\n    token_ptr: Option<*mut ERC721Token>,\n    token_details_buffer: Vec<u8>, // Use a dynamic Vec<u8> for the buffer\n}\n\nstatic mut GLOBAL_STATE: GlobalState = GlobalState {\n    token_ptr: None,\n    token_details_buffer: Vec::new(), // Initialize with an empty Vec\n};\n\n#[generate_abi]\nimpl ERC721Token {\n    fn deserialize_from_memory(buffer: *const u8, len: usize) -> Result<ERC721Token, Box<dyn std::error::Error>> {\n        let reader = unsafe { Cursor::new(std::slice::from_raw_parts(buffer, len)) };\n        let token = deserialize_from(reader)?;\n        Ok(token)\n    }\n    #[no_mangle]\n    pub fn to_memory(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n        let serialized_data = serialize(self)?;\n        Ok(serialized_data)\n    }\n    #[no_mangle]\n    pub extern \"C\" fn initialize(\n        name_ptr: *mut u8,\n        name_len: usize,\n        symbol_ptr: *mut u8,\n        symbol_len: usize,\n    ) {\n        // Extract name and symbol from wasm memory\n        let name = extract_string_from_wasm_memory(name_ptr, name_len);\n        let symbol = extract_string_from_wasm_memory(symbol_ptr, symbol_len);\n\n        let token = ERC721Token {\n            name: name,\n            symbol: symbol,\n            owner_of: Vec::new(),\n            token_to_ipfs: Vec::new(),\n            token_id: 0,\n        };\n\n        // Box and convert the token into a raw pointer\n        let token_ptr = Box::into_raw(Box::new(token));\n        unsafe {\n            GLOBAL_STATE.token_ptr = Some(token_ptr);\n        }\n    }\n\n    #[no_mangle]\n    pub extern \"C\" fn mint(\n        owner_ptr: *const u8,\n        owner_len: usize,\n        ipfs_hash_ptr: *const u8,\n        ipfs_hash_len: usize,\n    ) -> u32 {\n        let token = match unsafe { GLOBAL_STATE.token_ptr } {\n            Some(ptr) => unsafe { &mut *ptr },\n            None => {\n                println!(\"Mint: Failed to mint, uninitialized TOKEN_PTR.\");\n                return u32::MAX; // Error value indicating uninitialized TOKEN_PTR.\n            }\n        };\n        // Convert raw pointers to Rust strings using from_utf8_lossy\n        let owner_slice = unsafe { std::slice::from_raw_parts(owner_ptr, owner_len) };\n}\n}"
}